#!/bin/bash
#
# ARG_POSITIONAL_SINGLE([release_name],[Release name. Allowed: v<major>.<minor>.<patch>, v<major>.<minor>.<patch>-rc.<num>, v<major>.<minor>.<patch>-alpha.<num>],[])
# ARG_POSITIONAL_SINGLE([release_source],[Release source: a git tag, git branch name, or a git commit hash.],[origin/master])
# ARG_OPTIONAL_BOOLEAN([test],[],[Runs a test])
# ARG_HELP([Simplifies creation of release branches.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


die()
{
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}


begins_with_short_option()
{
  local first_option all_short_options='h'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_release_source="origin/master"
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_test="off"


print_help()
{
  printf '%s\n' "Simplifies creation of release branches."
  printf 'Usage: %s [--(no-)test] [-h|--help] <release_name> [<release_source>]\n' "$0"
  printf '\t%s\n' "<release_name>: Release name. Allowed: v<major>.<minor>.<patch>, v<major>.<minor>.<patch>-rc.<num>, v<major>.<minor>.<patch>-alpha.<num>"
  printf '\t%s\n' "<release_source>: Release source: a tag, git branch name, or a git commit hash. (default: 'origin/master')"
  printf '\t%s\n' "--test, --no-test: Runs a test (off by default)"
  printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
  _positionals_count=0
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      --no-test|--test)
        _arg_test="on"
        test "${1:0:5}" = "--no-" && _arg_test="off"
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      *)
        _last_positional="$1"
        _positionals+=("$_last_positional")
        _positionals_count=$((_positionals_count + 1))
        ;;
    esac
    shift
  done
}


handle_passed_args_count()
{
  local _required_args_string="'release_name'"
  test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 1 and 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 1 and 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
  local _positional_name _shift_for=$1
  _positional_names="_arg_release_name _arg_release_source "

  shift "$_shift_for"
  for _positional_name in ${_positional_names}
  do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# exit when something fails
set -eE
# keep track of the last executed command
trap 'last_command=$current_command; current_command=$BASH_COMMAND' DEBUG
# echo an error message before exiting
trap 'printf "\e[31m%s: %s\e[m\n" "\"${last_command}\" failed with exit code" $?.' ERR

release_regex='^v\([0-9]\+\.\?\)\{3\}\(\(-rc\|-alpha\)\.[0-9]\+\)\?$'

if echo $_arg_release_name | grep -q $release_regex; then
  if [[ $_arg_test == "on" ]]; then
    echo "Test: Pass"
    exit 0
  fi

  git fetch # update remote tracking branches

  echo "Create release '$_arg_release_name' from '$_arg_release_source'"
  git branch $_arg_release_name $_arg_release_source # create release branch from a git source

  read -p "Push release '$_arg_release_name' to origin, do you want to continue? [y/N]: " _push

  if [[ $_push == "y" ]]; then
    git push origin $_arg_release_name # push release branch to remote
  else
    echo "Push to origin aborted"
  fi

  git branch -D $_arg_release_name # clean-up local
else
  if [[ $_arg_test == "on" ]]; then
    echo "ERROR: invalid release name: $_arg_release_name"
    echo "Test: Fail"
    exit 1
  fi

  echo "ERROR: invalid release name: $_arg_release_name"
  echo ""
  print_help
  exit 1
fi

# ] <-- needed because of Argbash
